# RFC-0009: Controller Unit Testing

**Authors:** Glyn Normington

**Status:**

**Pull Request URL:** https://github.com/projectriff/riff/pull/1372

**Superseded by:** N/A

**Supersedes:** N/A

**Related:** N/A


## Problem
The Kubernetes controllers in riff need unit testing in a consistent way. Other projects
have adopted and promoted various ways of testing controllers. For ease of maintenance,
riff needs to adopt a single, consistent approach.

For the purpose of this document, unit testing refers to testing the
`Reconcile` method of a controller.

Apart from checking that various objects are created etc., it should be straightforward
to test error paths by injecting errors in object lookup and creation.

### Anti-Goals

It is not a goal of this RFC to tie down the details of the test framework.

## Solution

The approach taken is to use a fake Kubernetes client and introduce a test framework
which allows tests to be written in a declarative style. See "Rejected Alternatives" below for 
some other approaches which were tried out.

The test framework supports table-driven tests. Each row of the table tests a single call to `Reconcile` by
setting up some initial Kubernetes objects, modifying the client behaviour using various hooks
or reactors, and then asserting that various Kubernetes objects are created, updated, tracked, etc.

When a helper function (a utility function provided by a test) is used to construct a Kubernetes object, it should
construct a fixed value and any variations should be explicitly coded in the table row. This avoids details of a
particular test being "buried" in helper functions.

Since kubebuilder was used to generate the controllers, some packages contain more than one controller and so
helper functions need to be named or organised carefully to avoid clashes. 

### User Impact

Users of riff are not impacted.

### Backwards Compatibility and Upgrade Path

Not applicable.

## Rejected Alternatives

### Testing with a Local Control Plane
riff's controllers were generated by kubebuilder and depend on the controller
runtime. Kubebuilder recommends integration testing using a local control plane.

This was rejected because the control plane
(specifically `etcd`) sometimes fails to start, which causes intermittent test failures.
Such failures are a time sink when developers, particularly newcomers, end up diagnosing
false positives, especially in CI.

A local control plane also complicates tests because
deletion of Kubernetes objects is not synchronous and so this needs to be worked around by
generating distinct object names or by other means.

Also, a local control plane is not
deterministic when it generates object names, which complicates the setting up of test
expectations.

See here for a quick
[spike](https://github.com/projectriff/system/pull/232) using a local control plane.

### Depending on Knative testing packages
Another approach which was quickly [spiked](https://github.com/projectriff/system/pull/233) and
rejected was to depend on Knative testing packages. This was abandoned because Knative uses a different client interface
to that used by controller runtime. Also, it was not possible to resolve the dependency management problems associated
with depending on Knative testing packages.

### BDD testing

[Ginkgo](http://onsi.github.io/ginkgo/) and [Gomega](https://onsi.github.io/gomega/) allow Behavior-Driven
Development(BDD) tests to be written in Go. One advantage of BDD is that it facilitates writing tests with
a tree structure and which can explore arbitrary "corners" of the behaviour in as much detail as necessary.

Reading a BDD test involves reading the test tree from root to leaves building up an understanding of the context in
which the tests run.

Table-driven testing was chosen instead so that each test could simply be read from a row of the table without
having to perform a mental calculation of the test context. 

## FAQ
